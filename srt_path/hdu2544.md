
# 问题描述
>  在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？

# 算法思想
* ### 松弛操作
      原来用一根橡皮筋连接a、b两点，现在有一点v到b的距离更短，则把橡皮筋的a点换成v点，使得v、b连接在一起。这样缓解橡皮筋紧绷的压力，使其变得松弛，即松弛操作。

      即更新两点的最短路径



* ### Floyd算法( O( $n^3$ ) )

      让每个点都做一次跳板，去松弛所有的，这样可以求出来任意两个点之间.
      
      对于每一个节点k，我们检查Dis(i,k) + Dis(k,j) < Dis(i,j)是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们便设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。

* ### Dijkstra算法+堆优化( O( ElogE ) )
      从源点出发，找距离它最短的一个点，再以这个点为跳板，找离跳板最近的点

      当不能继续进行时，再次回到源点，找第二小的点，重复操作，直到所有的点
      都被访问过为止 . 注意，每个点只能访问一次.
      
      使用优先队列来存储可松弛的点,取队首,可大大降低复杂度


* ### SPFA算法( O( EK ) )
      首先先将起点
      放入队列，然后将它拿出，对其他点进行松弛，
      
      如果松弛成功，则将其放进队列（前提是它不在队列中）.

      每一次都把队首的点拿出来进行松弛，直到队列为空，注意，点可以重复入队

# 求解过程
```
/*
    title: 求最短路
 

    solution: 
            flyod 算法

            通过传递闭包来不断更新最短路
    
    date : 2019.2.21
*/





#include<bits/stdc++.h>
#define INF 99999
using namespace std;
int dis[110];//dis[i]表示从起点到i的距离
int mapp[110][110];//map[i][j]表示从i到j的距离
bool used[110];//标记某点是否用过
int n,m;
using namespace std;


void fly( int n)
{
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
    {
        mapp[i][j]=min( mapp[i][j],mapp[i][k]+mapp[k][j]);
    }
    printf("%d\n",mapp[1][n]);

}

int main()
{
    while(scanf("%d%d",&n,&m)!=EOF)
    {
        if(n==0&&m==0)
        break;
        memset(dis,INF,sizeof(dis));
        memset(used,false,sizeof(used));
        for(int i=1;i<=n;i++)//初始化
        {
            for(int j=1;j<=n;j++)
            {
                mapp[i][j]=INF;
            }
        }
        //mapp[0][0]=0;
        while(m--)
        {
            int a,b,p;
            scanf("%d%d%d",&a,&b,&p);
            if(mapp[a][b]>p||mapp[b][a]>p) //shortest road
            {
                mapp[a][b]=p;
                mapp[b][a]=p;
            }
        }
        fly(n);
    }
    return 0;

}


```